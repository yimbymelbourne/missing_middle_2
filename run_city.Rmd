---
title: "`r params$doc_title`"
author: "YIMBY Melbourne"
date: "2024-02-13"
output:
  html_document:
    css: "theme/yimby_mel.css"
params:
  doc_title: "Heritage and Zoning for a Small Area of Melbourne" # Default value
  area: "Small area"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE, echo = FALSE, fig.width = 7, fig.height = 4)

parcels <- prettyNum(nrow(dwelling_data),big.mark = ",")

fois <- dwelling_data %>% 
  filter(feature_preventing_development) %>% 
  nrow()%>% 
  prettyNum(big.mark = ",")
  
bad_zoning <- dwelling_data %>% 
    filter(!feature_preventing_development) %>% 
  group_by(zoning_permits_housing) %>% 
  summarise(n=n()) %>% 
  filter(zoning_permits_housing == "Housing not generally permitted") %>% 
  pull(n) %>% 
  prettyNum(big.mark = ",")

already_developed <- dwelling_data %>% 
  filter(zoning_permits_housing == "Housing permitted",
         !feature_preventing_development,
         dwellings_est>1) %>%
  nrow()%>% 
  prettyNum(big.mark = ",")


useful_lots_sf <- dwelling_data_sf %>% 
    filter(zoning_permits_housing == "Housing permitted",
         dwellings_est<2,
         !(feature_preventing_development)
         ) 

useful_lots <- useful_lots_sf %>% 
  st_drop_geometry()

n_heritage <- useful_lots %>% filter(heritage == TRUE) %>% nrow
percent_heritage <- (useful_lots %>% filter(heritage == TRUE) %>% nrow / useful_lots %>% nrow) * 100
averages <- params$melbourne_averages

useful_lots_num <-  prettyNum(nrow(useful_lots),big.mark = ",")

mcg_size <- 20000 

```

## How much land is in `r params$area`? 

There are `r parcels` parcels of land in `r params$area`. But not every piece of land can have housing on it. Of these parcels, `r fois` are on civic land like schools, hospitals, or train stations where development is challenging. Another `r bad_zoning` are in zones that do not development. Finally `r already_developed` properties have already been developed with more than 1 unit, making re-development difficult. 

That leaves `r useful_lots_num` that are available for development. The size of these lots is `r prettyNum(sum(useful_lots$lot_size),big.mark = ",")` square meters, or `r round(as.numeric(sum(useful_lots$lot_size))/mcg_size)` MCGs worth of space to build housing. 

### Heritage Coverage

Out of the `r useful_lots_num` lots available for development, `r n_heritage` are covered under a heritage overlay, restricting the ability to build new housing. In total, heritage covers `r percent_heritage` of the usable lots in `r params$area`. This is `r ifelse(percent_heritage > melbourne_averages$useful_lots_heritage_pc, "above", "below")` the Melbourne average  of `r melbourne_averages$useful_lots_heritage_pc `.

## Land in `r params$area`` {.tabset}
### By number of lots

```{r}

dwellings_by_type <- dwelling_data %>%
  group_by(type_short,heritage) %>% 
  summarise(n = n(),
            lot_size = sum(lot_size),
            .groups = "drop") %>% 
  group_by(type_short) %>% 
  mutate(n_total = sum(n),
         lot_size_total = sum(lot_size))  %>% 
  ungroup() %>% 
  mutate(heritage = if_else(heritage,
                            "Subject to heritage controls",
                            "Free from heritage controls")) 

dwellings_by_type %>% 
  mutate(type_short = fct_reorder(type_short,n_total)) %>% 
  ggplot(aes(x = type_short, 
             y = n,
             fill = heritage))+
  coord_flip()+ 
  geom_bar(stat = "identity")+
  theme_yimby_mel_caption(text_size = "small",plot_type = "bar",colour_scale = "light_dark") +
  labs(x = element_blank(),
       title = paste0("Land in ",params$area," by type"),
       y = "Number of properties",
       fill = "Heritage status")

```

### By total area

```{r by total area}
dwellings_by_type %>% 
    mutate(type_short = fct_reorder(type_short,lot_size_total)) %>%
  ggplot(aes(x = type_short, 
             y = lot_size_total,
             fill = heritage))+
  coord_flip()+ 
  geom_bar(stat = "identity")+
  theme_yimby_mel_caption(text_size = "small",plot_type = "bar",colour_scale = "light_dark") +
  labs(x = element_blank(),
       title = paste0("Land in ",params$area," by type"),
       y = "Area (sqm)",
       fill = "Heritage status")+
  scale_y_continuous(labels = scales::number_format(big.mark = ","))

```

### Table


```{r}
library(kableExtra)
library(gt)

types_zonning <- dwellings_by_type %>% 
  group_by(heritage) %>% 
  summarise(n = sum(n),
            lot_size = sum(lot_size)) %>% 
  mutate(type_short = "Total")




types_total_new <- dwelling_data %>%
  filter(!feature_preventing_development,
         zoning_permits_housing == "Housing permitted",
         dwellings_est < 2) %>% 
  group_by(heritage) %>% 
  summarise(n = n(),
            lot_size = sum(lot_size),
            .groups = "drop") %>% 
  mutate(heritage = if_else(heritage,
                            "Subject to heritage controls",
                            "Free from heritage"),
         type_short = "Total where new housing can be built") 


dwellings_by_type %>% 
  bind_rows(types_zonning) %>% 
  bind_rows(types_total_new) %>% 
  group_by(type_short) %>% 
  mutate(`Share of properties that are heritage` = paste0(round(100*n/sum(n)),"%"),
         `Share of land that is heritage` =  paste0(round(100*lot_size/sum(lot_size)),"%")
         ) %>% 
  rename(`Number of properties` = n,
         `Area (sqm)` = lot_size,
         ` ` = heritage) %>% 
  select(-n_total,-lot_size_total) %>% 
    gt()  %>% 
  fmt_number(decimals = 0)

  

```



## Lot sizes in Yarra {.tabset}

Larger lots can be easier to develop, but Melbourne has been sucssessful in developing even on small lots

### By number of lots

```{r cars}
library(ggridges)




dwelling_data %>%
  ggplot() + 
  geom_density_ridges(aes(x = lot_size, 
                     fill = heritage_nice,
                     group = paste0(type_short,heritage),
                     y = type_short,
                     weight = lot_size
                     ),
                     alpha = .8) +
  xlim(0,2000)+
  theme_yimby_mel_caption(text_size = "small",plot_type = "bar",colour_scale = "light_dark") +
  labs(title = paste0("Land in ",params$area," by size of each lot"),
       subtitle = "Height represents the number of lots of each size",
       fill = "Heritage",
      x = "Size of individual lots",
      y = element_blank())

```

### By area

```{r }

 dwelling_data[rep(seq_along(round(as.numeric(dwelling_data$lot_size/50))), round(as.numeric(dwelling_data$lot_size/50))), ] %>%
  mutate(group_name = paste0(type_short,heritage)) %>%
  ggplot() + 
  geom_density_ridges(aes(x = lot_size, 
                     fill = heritage_nice,
                     group = group_name,
                     y = type_short,
                     ),
                     alpha = .8) +
  xlim(0,2000) +
  theme_yimby_mel_caption(text_size = "small",
                          plot_type = "bar",
                          colour_scale = "light_dark") +
  labs(title = paste0("Land in ",params$area," by size of each lot"),
      subtitle = "Height represents the total area taken up by lots of a given lot size",
       fill = "Heritage",
      x = "Size of individual lots",
      y = element_blank())


```

## Map

```{r }


sf::sf_use_s2(FALSE)  # Disable s2 engine

lot_by_type <- dwelling_data_sf %>%
  mutate(category = case_when(feature_preventing_development ~ "Civic use makes development less likely",
         heritage        ~ "Subject to heritage controls",
         dwellings_est >1 ~ "Already developed",
         zoning_permits_housing != "Housing permitted" ~ "Housing not permitted",
         T ~ zone_short)) %>%
    st_buffer(0) %>%
  mutate(geometry = lwgeom::lwgeom_make_valid(geom)) %>%
  mutate(category = as.factor(category)) %>%
  group_by(category) %>% 
  summarise(geometry = st_union(st_combine(geometry))) %>% 
  st_simplify() 



# Assume lot_by_type$category has levels A, B, C, D, E
# And you want to specify colors for A and B

# Specific colors for certain levels
specified_colors <- c("Already developed" = "grey",
                      "Housing not permitted" = "darkgrey",
                      "Civic use makes development less likely" = "#c5ecd0", 
                      "Subject to heritage controls" = yimby_colours$complementary[1],
                      "Low density residential" =  yimby_colours$complementary[3],
                      "Neighbourhood residential" =  yimby_colours$blue_palette[1],
                      "General residential" =  yimby_colours$blue_palette[2],
                      "Residenrial Growth" =  yimby_colours$yellow_palette[1],
                      "Mixed use" =  yimby_colours$yellow_palette[2],
                      "Commercial" = yimby_colours$blue_base[3])

# Fallback colors
fallback_colors <- rev(yimby_colours$green_palette[2-4])  # Assuming this is a vector of color codes

# All unique levels of the factor
all_levels <- levels(lot_by_type$category)

# Prepare a color vector that includes specified colors and fills the rest from fallback_colors
colors_for_all_levels <- ifelse(all_levels %in% names(specified_colors),
                                specified_colors[all_levels],
                                fallback_colors[1:length(all_levels)])

# Ensure the length of fallback colors is sufficient
if (length(colors_for_all_levels) < length(all_levels)) {
  warning("Not enough fallback colors provided. Repeating fallback colors to match the number of levels.")
  needed <- length(all_levels) - length(colors_for_all_levels)
  colors_for_all_levels <- c(colors_for_all_levels, rep(fallback_colors, length.out = needed))
}

# Assign names to ensure the colors align with the factor levels
names(colors_for_all_levels) <- all_levels

# Use colors_for_all_levels in your plotting function
palette <- colorFactor(palette = colors_for_all_levels, domain = lot_by_type$category)



lot_by_type %>%
  st_transform("wgs84") %>% 
  st_simplify() %>% 
  mutate(category = fct_relevel(category,names(specified_colors))) %>%
  leaflet(width = "100%") %>%
addProviderTiles(providers$CartoDB.Positron)%>%
  addPolygons(weight = .1,
              color = "black",
              fillColor = ~palette(category),
              fillOpacity = .8,
  label = ~category,
  labelOptions = labelOptions(
    style = list("font-weight" = "normal", padding = "3px 8px"),
    textsize = "15px",
    direction = "auto")) %>%
   addLegend(pal = palette,
            values = ~category,
            title = "Type of land",
            position = "bottomright",
            opacity = .8)

```

### Population and Density
``` {r }

density = mel_lga_populations %>% filter(lga_name_2021 == params$area) %>% select(final_density)
change_population = mel_lga_populations %>% filter(lga_name_2021 == params$area) %>% select(population_growth)

```

`r params$area` population has grown with a percentage change of `r change_population` from `r start_year` until `r end_year`, where all of Melbourne has grown by `r melbourne_averages$melbourne_population_change_pc`


`r params$area` has a density of `r density` (pop/sqkm), which is `r ifelse(density > melbourne_averages$melbourne_average_density_raw, "above", "below" )` the Melbourne average of `r melbourne_averages$melbourne_average_density_raw`.



## Other ideas


### Eligibility for Future Homes

### Current v YIMBY Melbourne zoned capacity

We could figure out what current zoned capacity is and then figure out what it would be 

### Proximity to Public transport

Most inner LGAs have much better public transport and we could show that 

### Recent development in Yarra
Show how nothing gets built in GRZ. 